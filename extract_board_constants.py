"""
This script extracts mappings between tile IDs, node IDs, coordinates, 
and ports from Catanatron's default map and saves them to board_constants.py.
These remain the same between all games.

Usage: `uv run python extract_board_constants.py`
"""

from catanatron.models.map import (
    CatanMap,
    BASE_MAP_TEMPLATE,
    LandTile,
    Port,
    PORT_DIRECTION_TO_NODEREFS,
    NUM_NODES,
)


def extract_all():
    m = CatanMap.from_template(BASE_MAP_TEMPLATE)

    # Tile ID <-> coordinate
    tile_id_to_coord = {}
    for coord, tile in m.tiles.items():
        if isinstance(tile, LandTile):
            tile_id_to_coord[tile.id] = coord

    # Node -> adjacent tile IDs
    node_to_tile_ids = {}
    for node_id in sorted(m.adjacent_tiles.keys()):
        node_to_tile_ids[node_id] = sorted(t.id for t in m.adjacent_tiles[node_id])

    # Node adjacency (edge connections)
    node_adjacency = {n: [] for n in range(NUM_NODES)}
    for coord, tile in m.tiles.items():
        if isinstance(tile, LandTile):
            for a, b in tile.edges.values():
                if a < NUM_NODES and b < NUM_NODES:
                    if b not in node_adjacency[a]:
                        node_adjacency[a].append(b)
                    if a not in node_adjacency[b]:
                        node_adjacency[b].append(a)
    for n in node_adjacency:
        node_adjacency[n].sort()

    # Port coordinate -> land node pair
    port_coord_to_nodes = {}
    for coord, tile in m.tiles.items():
        if isinstance(tile, Port):
            nr1, nr2 = PORT_DIRECTION_TO_NODEREFS[tile.direction]
            n1, n2 = tile.nodes[nr1], tile.nodes[nr2]
            land_nodes = sorted(n for n in (n1, n2) if n < NUM_NODES)
            port_coord_to_nodes[coord] = land_nodes

    return tile_id_to_coord, node_to_tile_ids, node_adjacency, port_coord_to_nodes


def format_dict(d, value_fmt="repr"):
    lines = []
    for k in sorted(d.keys()):
        v = d[k]
        if value_fmt == "tuple" and isinstance(v, (list, tuple)):
            v_str = repr(tuple(v))
        else:
            v_str = repr(v)
        lines.append(f"    {k!r}: {v_str},")
    return "{\n" + "\n".join(lines) + "\n}"


def write_constants(
    tile_id_to_coord,
    node_to_tile_ids,
    node_adjacency,
    port_coord_to_nodes,
    output_path="board_constants.py",
):
    with open(output_path, "w") as f:
        f.write('"""\n')
        f.write("Fixed board topology constants for the standard Catan map.\n")
        f.write("\n")
        f.write("Extracted from Catanatron's CatanMap. These are invariant across games --\n")
        f.write("only tile resources/numbers and port resource assignments change per game.\n")
        f.write("\n")
        f.write("Tile IDs 0-18 correspond to the 19 land tiles in BFS order from center.\n")
        f.write("Node IDs 0-53 correspond to the 54 settlement positions.\n")
        f.write("\n")
        f.write("Generated by extract_board_constants.py\n")
        f.write('"""\n\n')

        f.write("# Tile ID -> cube coordinate (x, y, z) where x + y + z = 0\n")
        f.write("# Layer 0 (center): tile 0\n")
        f.write("# Layer 1 (ring 1): tiles 1-6\n")
        f.write("# Layer 2 (ring 2): tiles 7-18\n")
        f.write(f"TILE_ID_TO_COORD = {format_dict(tile_id_to_coord, 'tuple')}\n\n")

        f.write("COORD_TO_TILE_ID = {v: k for k, v in TILE_ID_TO_COORD.items()}\n\n")

        f.write("# Node ID -> list of adjacent land tile IDs\n")
        f.write("# Interior nodes touch 3 tiles, edge nodes touch 1-2 tiles\n")
        f.write(f"NODE_TO_TILE_IDS = {format_dict(node_to_tile_ids)}\n\n")

        f.write("# Node ID -> list of adjacent node IDs (connected by road edges)\n")
        f.write(f"NODE_ADJACENCY = {format_dict(node_adjacency)}\n\n")

        f.write("# Port coordinate -> pair of land node IDs that get port access\n")
        f.write("# The resource assigned to each port varies per game (read from board_layout).\n")
        f.write("# Ports with resource=null in the data are 3:1 generic ports.\n")
        f.write(f"PORT_COORD_TO_NODES = {format_dict(port_coord_to_nodes)}\n\n")

        f.write("# Dice number -> probability (out of 36 total outcomes)\n")
        f.write("# Used to compute production value for each tile\n")
        f.write("NUMBER_PROBABILITIES = {\n")
        for n in range(2, 13):
            pips = 6 - abs(n - 7)
            f.write(f"    {n}: {pips} / 36,\n")
        f.write("}\n\n")

        f.write('RESOURCES = ["BRICK", "WOOD", "SHEEP", "WHEAT", "ORE"]\n\n')

        f.write(f"NUM_NODES = {NUM_NODES}\n")
        f.write(f"NUM_TILES = {len(tile_id_to_coord)}\n")

    print(f"Wrote {output_path}")


def main():
    data = extract_all()
    write_constants(*data)


if __name__ == "__main__":
    main()
